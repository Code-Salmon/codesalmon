
Example SourceFile:

SourceFile {
  fileName: '/path/to/file.ts',
  text: `
    import fetch from 'node-fetch';

    const apiUrl = 'https://api.example.com';  <-- url grab
    fetch(apiUrl, { method: 'GET', headers: { Authorization: 'Bearer token' } });
  `,
  statements: [
    ImportDeclaration {                  
      moduleSpecifier: 'node-fetch',         <--- statements.ImportDeclaration.modulSpecifier = fetch identifier
      namedImports: ['fetch']
    },
    VariableStatement {
      declaration: {
        name: 'apiUrl',
        initializer: StringLiteral { text: 'https://api.example.com' }
      }
    },
    ExpressionStatement {
      expression: CallExpression {
        expression: Identifier { text: 'fetch' },
        arguments: [
          StringLiteral { text: 'https://api.example.com' },
          ObjectLiteralExpression {
            properties: [
              PropertyAssignment {
                name: 'method',
                initializer: StringLiteral { text: 'GET' }
              },
              PropertyAssignment {
                name: 'headers',
                initializer: ObjectLiteralExpression {
                  properties: [
                    PropertyAssignment {
                      name: 'Authorization',
                      initializer: StringLiteral { text: 'Bearer token' }
                    }
                  ]
                }
              }
            ]
          }
        ]
      }
    }
  ]
}


     // if statement to check if variable is in env
            // have considered api key within header
            // NOTE TO USER - if key is exposed - console log the warning - suggest making it a .env variable

            // const apiURLGrab = code.match(/fetch\(['"](.+?)['"]/);
            // const apiURLGrab = code.match(/fetch\s*\(\s*['"]([^'"]+)['"]/);

            // console.log('apiURLGrab:', apiURLGrab);
            // if (apiURLGrab) {
            //   const apiURL = apiURLGrab[1];
            //   console.log('apiURL =', apiURL);
            //   // the word fetch would be the [0] the url is the [1]
            //   try {

            //     const response = await fetch(apiURL, { headers });

            //     const data = await response.json();
            //     console.log(`Response data from ${apiURL}:`, data);
            //     fileFolder(data as Record<string, unknown>);
            //   } catch (error) {
            //     console.error(`Error making test call to ${apiURL}:`, error);
            //   }
            // }


            How many loops to modularize:
    1. sourceFile of source
      a. initializing all array and object storage variables 
      b. getting all call expressions and variable declarations 
    2. https of variableDeclarations
      a. 
    3. c of calls 
      a. 
    4. def of defs
      a. 

URLString: PropertyAccessExpression {
  _wrappedChildCount: 0,
  _context: ProjectContext {
    logger: ConsoleLogger {},
    lazyReferenceCoordinator: LazyReferenceCoordinator {},
    directoryCoordinator: DirectoryCoordinator {},
    fileSystemWrapper: TransactionalFileSystem {},
    manipulationSettings: ManipulationSettingsContainer { _settings: [Object] },
    structurePrinterFactory: StructurePrinterFactory {
      _getFormatCodeSettings: [Function (anonymous)]
    },
    compilerFactory: CompilerFactory { documentRegistry: DocumentRegistry {} },
    inProjectCoordinator: InProjectCoordinator {}
  },
  __sourceFile: <ref *1> SourceFile {
    _wrappedChildCount: 9,
    _context: ProjectContext {
      logger: ConsoleLogger {},
      lazyReferenceCoordinator: LazyReferenceCoordinator {},
      directoryCoordinator: DirectoryCoordinator {},
      fileSystemWrapper: TransactionalFileSystem {},
      manipulationSettings: [ManipulationSettingsContainer],
      structurePrinterFactory: [StructurePrinterFactory],
      compilerFactory: [CompilerFactory],
      inProjectCoordinator: InProjectCoordinator {}
    },
    __sourceFile: [Circular *1],
    _referenceContainer: SourceFileReferenceContainer {},
    _hasBom: undefined,
    _inProject: true
  }
}


Commenting

const arrayofFetchAPIs: string[] = [];

// for (const c of calls) {
    //   const expr = c.getExpression(); //reads each call expression found
      
    //   const isDirectFetch = expr.getText() === 'fetch'; //these 3 lines will check for the type of call expression
    //   const isWindowFetch = expr.getText() === 'window.fetch';
    //   const isGlobalFetch = expr.getText() === 'globalThis.fetch';
    //   // console.log('testing if this will log')
    //   // console.log('c:', c)
    //   if (isDirectFetch || isWindowFetch || isGlobalFetch) {
    //     //if it matches, get the text and write it to a json object file
    //     const code = c.getText(); // build in TS-Morph more appropriate?? seeing .getArguments();
    //     // console.log('code:', code)
    //     //Extract headers from fetch second argument (if present)
    //     const args = c.getArguments();
    //     // console.log('ARGS:', args)
    //     if (args.length > 0) {
    //       const arg0 = args[0];

    //       if (arg0.getKind() === SyntaxKind.StringLiteral) {
    //         const apiURL = arg0.getText().replace(/^['"`]|['"`]$/g, '');
    //         console.log('Extracted API URL:', apiURL);

    //         if(!arrayofFetchAPIs.includes(apiURL)) {
    //           arrayofFetchAPIs.push(apiURL);
    //         }
    //       }
    //       else if (arg0.getKind() === SyntaxKind.Identifier) {
    //         const identifier = arg0.asKindOrThrow(SyntaxKind.Identifier);
    //         const defs = identifier.getDefinitionNodes();

    //         for (const def of defs) {
    //           if (def.getKind() === SyntaxKind.VariableDeclaration) {
    //           const varDecl = def.asKindOrThrow(SyntaxKind.VariableDeclaration);
    //           const init = varDecl.getInitializer();
        
    //             if (init?.getKind() === SyntaxKind.StringLiteral) {
    //             const url = init.getText().replace(/^['"`]|['"`]$/g, '');
    //             console.log('✅ Resolved from identifier:', url);
                
    //               if(!arrayofFetchAPIs.includes(url)) {
    //               arrayofFetchAPIs.push(url);
    //             }
                
    //             } else {
    //             console.warn('⚠️ Could not resolve literal for identifier:', arg0.getText());
    //           }
    //       }
    //     }
    //         } else {
    //           console.warn('Fetch call does not use a string literal or identifier for the URL:', arg0.getText());
    //         }
    //       }
    //     }
    //   }